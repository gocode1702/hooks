import {
  __commonJS
} from "./chunk-AC2VUBZ6.js";

// node_modules/accordion/src/accordion.js
var require_accordion = __commonJS({
  "node_modules/accordion/src/accordion.js"(exports, module) {
    (function() {
      "use strict";
      var touchEnabled = "ontouchstart" in document.documentElement;
      var pressEvent = touchEnabled ? "touchend" : "click";
      var each = [].forEach;
      var transitionEnd = function() {
        for (var names = "transitionend webkitTransitionEnd oTransitionEnd otransitionend".split(" "), i = 0; i < 4; ++i)
          if ("on" + names[i].toLowerCase() in window)
            return names[i];
        return names[0];
      }();
      function setToken(list, token, enabled) {
        enabled ? list.add(token) : list.remove(token);
      }
      function debounce(fn, limit, soon) {
        var limit = limit < 0 ? 0 : limit, started, context, args, timer, delayed = function() {
          var timeSince = Date.now() - started;
          if (timeSince >= limit) {
            if (!soon)
              fn.apply(context, args);
            if (timer)
              clearTimeout(timer);
            timer = context = args = null;
          } else
            timer = setTimeout(delayed, limit - timeSince);
        };
        return function() {
          context = this, args = arguments;
          if (!limit)
            return fn.apply(context, args);
          started = Date.now();
          if (!timer) {
            if (soon)
              fn.apply(context, args);
            timer = setTimeout(delayed, limit);
          }
        };
      }
      ;
      var uniqueID = function() {
        var IDs = {};
        var indexes = {};
        function uniqueID2(prefix, complex, length) {
          length = +(length || 6);
          var result = prefix = prefix || "_";
          if (!complex) {
            if (!indexes[prefix])
              indexes[prefix] = 0;
            result += ++indexes[prefix];
          } else {
            var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
            chars += chars.toLowerCase();
            result += chars[Math.round(Math.random() * (chars.length - 1))];
            chars += "0123456789";
            while (result.length < length)
              result += chars[Math.round(Math.random() * (chars.length - 1))];
          }
          return IDs[result] || document.getElementById(result) ? uniqueID2(prefix, complex) : (IDs[result] = true, result);
        }
        return uniqueID2;
      }();
      var cssTransform = function(n) {
        s = document.documentElement.style;
        if ((prop = n.toLowerCase()) in s)
          return prop;
        for (var prop, s, p = "Webkit Moz Ms O Khtml", p = (p.toLowerCase() + p).split(" "), i = 0; i < 10; ++i)
          if ((prop = p[i] + n) in s)
            return prop;
        return "";
      }("Transform");
      var css3DSupported = function(propName) {
        var e = document.createElement("div"), s = e.style, v = [["translateY(", ")"], ["translate3d(0,", ",0)"]];
        try {
          s[propName] = v[1].join("1px");
        } catch (e2) {
        }
        return v[+!!s[propName]] === v[1];
      }(cssTransform);
      var folds = [];
      var Fold = function(accordion, el) {
        var THIS = this;
        var heading = el.firstElementChild;
        var content = el.lastElementChild;
        var elClasses = el.classList;
        var openClass = accordion.openClass;
        var closeClass = accordion.closeClass;
        var keysEnabled = !accordion.noKeys;
        var useBorders = accordion.useBorders;
        var useTransforms = !accordion.noTransforms && cssTransform;
        var onToggle = accordion.onToggle;
        var _disabled = false;
        var _open, _y, _height, _ariaEnabled;
        var scrollX, scrollY;
        var onTouchStart;
        var onKeyDown;
        var onPress;
        Object.defineProperties(THIS, {
          fit: { value: fit },
          // Add or remove relevant ARIA attributes from the fold's elements
          ariaEnabled: {
            get: function() {
              return _ariaEnabled;
            },
            set: function(input) {
              if ((input = !!input) !== !!_ariaEnabled) {
                _ariaEnabled = input;
                if (input) {
                  heading.setAttribute("role", "tab");
                  content.setAttribute("role", "tabpanel");
                  checkIDs();
                  heading.setAttribute("aria-selected", !!_open);
                  heading.setAttribute("aria-expanded", !!_open);
                  content.setAttribute("aria-hidden", !_open);
                } else {
                  heading.removeAttribute("role");
                  heading.removeAttribute("aria-controls");
                  heading.removeAttribute("aria-selected");
                  heading.removeAttribute("aria-expanded");
                  content.removeAttribute("role");
                  content.removeAttribute("aria-labelledby");
                  content.removeAttribute("aria-hidden");
                }
              }
            }
          },
          // Whether or not the fold's currently opened
          open: {
            get: function() {
              if (void 0 === _open) {
                _open = elClasses.contains(openClass);
                setToken(elClasses, closeClass, !_open);
              }
              return _open;
            },
            set: function(input) {
              if ((input = !!input) !== _open) {
                if ("function" === typeof onToggle && false === onToggle.call(null, THIS, input))
                  return;
                setToken(elClasses, openClass, input);
                setToken(elClasses, closeClass, !input);
                _open = input;
                if (_ariaEnabled) {
                  heading.setAttribute("aria-selected", input);
                  heading.setAttribute("aria-expanded", input);
                  content.setAttribute("aria-hidden", !input);
                }
                if (THIS.needsRefresh) {
                  delete THIS.needsRefresh;
                  accordion.refresh();
                } else
                  accordion.update();
                if (accordion.modal && _open) {
                  for (var fold, i = 0, l = accordion.folds.length; i < l; ++i) {
                    if (THIS !== (fold = accordion.folds[i]))
                      fold.open = false;
                  }
                }
              }
            }
          },
          // Whether the fold's been deactivated
          disabled: {
            get: function() {
              return _disabled;
            },
            set: function(input) {
              if ((input = !!input) !== _disabled) {
                var style = el.style;
                if (_disabled = input) {
                  style.height = null;
                  useTransforms ? style[cssTransform] = null : style.top = null;
                  touchEnabled && heading.removeEventListener("touchstart", onTouchStart);
                  heading.removeEventListener(pressEvent, onPress);
                  elClasses.remove(openClass, closeClass);
                  if (onKeyDown) {
                    heading.removeEventListener("keydown", onKeyDown);
                    heading.removeAttribute("tabindex");
                  }
                  if (_ariaEnabled) {
                    THIS.ariaEnabled = false;
                    _ariaEnabled = true;
                  }
                } else {
                  style.height = _height + "px";
                  useTransforms ? style[cssTransform] = css3DSupported ? "translate3D(0," + _y + "px,0)" : "translateY(" + _y + "px)" : style.top = _y + "px";
                  touchEnabled && heading.addEventListener("touchstart", onTouchStart);
                  heading.addEventListener(pressEvent, onPress);
                  if (onKeyDown) {
                    heading.addEventListener("keydown", onKeyDown);
                    heading.tabIndex = 0;
                  }
                }
              }
            }
          },
          // Vertical position of the fold within an accordion's container
          y: {
            get: function() {
              if (void 0 === _y)
                return _y = parseInt(el.style.top) || 0;
              return _y;
            },
            set: function(input) {
              if ((input = +input) !== _y) {
                _y = input;
                useTransforms ? el.style[cssTransform] = css3DSupported ? "translate3D(0," + input + "px,0)" : "translateY(" + input + "px)" : el.style.top = input + "px";
              }
            }
          },
          // Height of the fold's outermost container
          height: {
            get: function() {
              if (void 0 === _height) {
                _height = THIS.headingHeight + content.scrollHeight;
                el.style.height = _height + "px";
              }
              return _height;
            },
            set: function(input) {
              if (input && (input = +input) !== _height) {
                el.style.height = input + "px";
                _height = input;
              }
            }
          },
          // Current height of the fold's heading
          headingHeight: {
            get: function() {
              return heading.scrollHeight + THIS.heightOffset + (useBorders ? THIS.headingBorder : 0);
            }
          },
          // Total height consumed by the heading element's CSS borders, if any
          headingBorder: {
            get: function() {
              return (heading.offsetHeight || 0) - (heading.clientHeight || 0);
            }
          },
          // Total height of the fold's container element
          elHeight: {
            get: function() {
              return el.scrollHeight + (useBorders ? THIS.elBorder : 0);
            }
          },
          // Total height consumed by container element's CSS borders, if any
          elBorder: {
            get: function() {
              return (el.offsetHeight || 0) - (el.clientHeight || 0);
            }
          },
          // Whether the fold's container has been resized incorrectly
          wrongSize: {
            get: function() {
              return THIS.headingHeight + content.scrollHeight !== el.scrollHeight;
            }
          }
        });
        THIS.index = folds.push(THIS) - 1;
        THIS.accordion = accordion;
        THIS.el = el;
        THIS.heading = heading;
        THIS.content = content;
        THIS.ariaEnabled = !accordion.noAria;
        THIS.heightOffset = accordion.heightOffset;
        el.accordionFold = THIS.index;
        useBorders = "auto" === useBorders ? 0 !== THIS.elBorder + THIS.headingBorder : useBorders;
        function checkIDs() {
          var headingSuffix = "-heading";
          var contentSuffix = "-content";
          var elID = el.id;
          var id;
          if (!heading.id && !content.id) {
            id = elID || uniqueID("a");
            heading.id = id + headingSuffix;
            content.id = id + contentSuffix;
          } else if (!content.id)
            content.id = (elID || heading.id) + contentSuffix;
          else if (!heading.id)
            heading.id = (elID || content.id) + headingSuffix;
          var $ = function(s) {
            return document.querySelectorAll("#" + s);
          };
          while ($(content.id).length > 1 || $(heading.id).length > 1) {
            id = uniqueID("a");
            content.id = id + contentSuffix;
            heading.id = id + headingSuffix;
          }
          heading.setAttribute("aria-controls", content.id);
          content.setAttribute("aria-labelledby", heading.id);
        }
        if (keysEnabled) {
          heading.tabIndex = 0;
          heading.addEventListener("keydown", onKeyDown = function(e) {
            var key = e.keyCode;
            var fold;
            switch (key) {
              case 32:
                e.preventDefault();
              case 13:
                THIS.open = !THIS.open;
                if ("A" === e.target.tagName)
                  e.preventDefault();
                break;
              case 27:
                e.target.blur();
                break;
              case 38: {
                if (fold = THIS.previousFold) {
                  var children = fold.childAccordions;
                  if (fold.open && children) {
                    var lastAcc;
                    var lastFold;
                    while (children) {
                      lastAcc = children[children.length - 1];
                      lastFold = lastAcc.folds[lastAcc.folds.length - 1];
                      if (!lastFold.open)
                        break;
                      children = lastFold.childAccordions;
                    }
                    lastFold.heading.focus();
                  } else
                    fold.heading.focus();
                } else if (accordion.parent)
                  accordion.parentFold.heading.focus();
                else
                  return true;
                e.preventDefault();
                return false;
              }
              case 40: {
                var children = THIS.childAccordions;
                if (THIS.open && children)
                  children[0].folds[0].heading.focus();
                else if (fold = THIS.nextFold)
                  fold.heading.focus();
                else if (THIS.accordion.parent) {
                  var parent = THIS;
                  while (parent = parent.accordion.parentFold)
                    if (fold = parent.nextFold) {
                      fold.heading.focus();
                      break;
                    }
                  if (!parent)
                    return true;
                } else
                  return true;
                e.preventDefault();
                return false;
              }
              case 37: {
                if (THIS.open)
                  THIS.open = false;
                else if (accordion.parent)
                  accordion.parentFold.heading.focus();
                break;
              }
              case 39: {
                var children = THIS.childAccordions;
                if (!THIS.open)
                  THIS.open = true;
                else if (children)
                  children[0].folds[0].heading.focus();
                break;
              }
            }
          });
        }
        touchEnabled && heading.addEventListener("touchstart", onTouchStart = function(e) {
          scrollX = window.pageXOffset;
          scrollY = window.pageYOffset;
        }, { passive: true });
        heading.addEventListener(pressEvent, onPress = function(e) {
          if (e.target !== heading && heading.contains(e.target)) {
            if ("A" === e.target.tagName && e.target.href)
              return true;
          }
          if (e.type !== "touchend" || e.cancelable && window.pageXOffset === scrollX && window.pageYOffset === scrollY) {
            THIS.open = !THIS.open;
            e.preventDefault();
          }
          return false;
        });
        function fit() {
          var height = THIS.headingHeight;
          if (THIS.open)
            height += content.scrollHeight;
          if (useBorders)
            height += THIS.elBorder;
          THIS.height = height;
        }
      };
      var accordions = [];
      var activeAccordions = 0;
      var lastResizeRate;
      var Accordion = function(el, options) {
        var THIS = this;
        var elClasses = el.classList;
        var options = options || {};
        var edgeClass = void 0 === options.edgeClass ? "edge-visible" : options.edgeClass;
        var snapClass = void 0 === options.snapClass ? "snap" : options.snapClass;
        var enabledClass = void 0 === options.enabledClass ? "accordion" : options.enabledClass;
        var disabledClass = options.disabledClass;
        var _height, _disabled, _parent, _parentFold, _modal;
        Object.defineProperties(THIS, {
          update: { value: update },
          updateFold: { value: updateFold },
          refresh: { value: refresh },
          // Whether the accordion's been deactivated
          disabled: {
            get: function() {
              return _disabled;
            },
            set: function(input) {
              if ((input = !!input) !== _disabled) {
                var style = el.style;
                var folds3 = THIS.folds;
                enabledClass && setToken(elClasses, enabledClass, !input);
                disabledClass && setToken(elClasses, disabledClass, input);
                if (_disabled = input) {
                  style.height = null;
                  snapClass && elClasses.remove(snapClass);
                  if (edgeClass) {
                    el.removeEventListener(transitionEnd, THIS.onTransitionEnd);
                    elClasses.remove(edgeClass);
                  }
                  for (var i = 0, l = folds3.length; i < l; ++i)
                    folds3[i].disabled = true;
                  THIS.noAria || el.removeAttribute("role");
                  --activeAccordions;
                } else {
                  for (var i = 0, l = folds3.length; i < l; ++i)
                    folds3[i].disabled = false;
                  THIS.noAria || el.setAttribute("role", "tablist");
                  ++activeAccordions;
                  update();
                }
                if (activeAccordions <= 0) {
                  activeAccordions = 0;
                  Accordion.setResizeRate(false);
                } else if (lastResizeRate)
                  Accordion.setResizeRate(lastResizeRate);
              }
            }
          },
          // Get or set the accordion enclosing this one
          parent: {
            set: function(input) {
              _parent = input;
            },
            get: function() {
              var result = _parent;
              if (!result)
                return null;
              while (result) {
                if (!result.disabled)
                  return result;
                result = result.parent;
              }
              return null;
            }
          },
          // Get or set the fold of the accordion enclosing this one
          parentFold: {
            set: function(input) {
              _parentFold = input;
            },
            get: function() {
              var fold2 = _parentFold;
              if (!fold2)
                return null;
              var accordion2 = fold2.accordion;
              while (fold2 && accordion2) {
                if (!accordion2.disabled)
                  return fold2;
                if (accordion2 = accordion2.parent)
                  fold2 = accordion2.parentFold;
              }
              return null;
            }
          },
          // Height of the accordion's container element
          height: {
            get: function() {
              return _height;
            },
            set: function(input) {
              if (input && (input = +input) !== _height) {
                el.style.height = input + "px";
                _height = input;
              }
            }
          },
          // Whether one of the Accordion's folds has been resized incorrectly
          wrongSize: {
            get: function() {
              var a = this.folds;
              var l = a.length;
              var i = 0;
              for (; i < l; ++i)
                if (a[i].wrongSize)
                  return true;
              if (a = this.childAccordions) {
                for (; i < l; ++i)
                  if (a[i].wrongSize)
                    return true;
              }
              return false;
            }
          },
          // Top-level ancestor this accordion's nested inside
          root: {
            get: function() {
              var result = this;
              while (result) {
                if (!result.parent)
                  return result;
                result = result.parent;
              }
            }
          }
        });
        THIS.openClass = options.openClass || "open";
        THIS.closeClass = options.closeClass || "closed";
        THIS.modal = !!options.modal;
        THIS.noAria = !!options.noAria;
        THIS.noKeys = !!options.noKeys;
        THIS.noTransforms = !!options.noTransforms;
        THIS.index = accordions.push(THIS) - 1;
        THIS.heightOffset = +options.heightOffset || 0;
        THIS.useBorders = void 0 === options.useBorders ? "auto" : options.useBorders;
        THIS.onToggle = options.onToggle;
        var folds2 = [];
        each.call(el.children, function(i) {
          var fold2 = new Fold(THIS, i);
          folds2.push(fold2);
          var prev = folds2[folds2.length - 2];
          if (prev) {
            prev.nextFold = fold2;
            fold2.previousFold = prev;
          }
        });
        el.accordion = THIS.index;
        THIS.noAria || el.setAttribute("role", "tablist");
        THIS.el = el;
        THIS.folds = folds2;
        if (!options.disabled && enabledClass)
          elClasses.add(enabledClass);
        update();
        var next = el;
        while ((next = next.parentNode) && 1 === next.nodeType) {
          var fold = Accordion.getFold(next);
          if (fold) {
            var accordion = fold.accordion;
            THIS.parent = accordion;
            THIS.parentFold = fold;
            edgeClass && elClasses.remove(edgeClass);
            (accordion.childAccordions = accordion.childAccordions || []).push(THIS);
            (fold.childAccordions = fold.childAccordions || []).push(THIS);
            if (fold.open) {
              var scrollHeight = fold.el.scrollHeight;
              var distance = fold.headingHeight + fold.content.scrollHeight - scrollHeight || scrollHeight - fold.el.clientHeight;
              accordion.updateFold(fold, distance);
            }
            break;
          }
        }
        edgeClass && el.addEventListener(transitionEnd, this.onTransitionEnd = function(e) {
          if (!THIS.parent && e.target === el && "height" === e.propertyName && el.getBoundingClientRect().bottom > window.innerHeight)
            elClasses.remove(edgeClass);
        });
        this.disabled = !!options.disabled;
        function edgeCheck(offset) {
          if (edgeClass) {
            var box = el.getBoundingClientRect();
            var windowEdge = window.innerHeight;
            if (box.bottom + (offset || 0) < windowEdge)
              elClasses.add(edgeClass);
            else if (box.bottom > windowEdge)
              elClasses.remove(edgeClass);
          }
        }
        function updateFold(fold2, offset) {
          var next2 = fold2;
          var parentFold = THIS.parentFold;
          while (next2 = next2.nextFold)
            next2.y += offset;
          parentFold || edgeCheck(offset);
          fold2.height += offset;
          THIS.height += offset;
          parentFold && parentFold.open && THIS.parent.updateFold(parentFold, offset);
        }
        function update() {
          var y = 0;
          var height = 0;
          var i = 0;
          var l = folds2.length;
          var parentFold = THIS.parentFold;
          var fold2, diff;
          for (; i < l; ++i) {
            fold2 = folds2[i];
            fold2.y = y;
            fold2.fit();
            y += fold2.height;
            height += fold2.height;
          }
          diff = height - _height;
          parentFold ? parentFold.open && THIS.parent.updateFold(parentFold, diff) : edgeCheck(diff);
          THIS.height = height;
        }
        function refresh(allowSnap) {
          var snap = allowSnap ? snapClass : false;
          snap && elClasses.add(snap);
          THIS.update();
          THIS.childAccordions && THIS.childAccordions.forEach(function(a) {
            a.parentFold.open ? a.refresh(allowSnap) : a.parentFold.needsRefresh = true;
          });
          snap && setTimeout(function(e) {
            elClasses.remove(snap);
          }, 20);
        }
      };
      if ("function" === typeof IE8PP)
        Accordion = IE8PP(Accordion), Fold = IE8PP(Fold);
      Accordion.setResizeRate = function(delay) {
        var fn = function(e) {
          for (var a, i = 0, l = accordions.length; i < l; ++i) {
            a = accordions[i];
            a.parent || a.disabled || a.refresh(true);
          }
        };
        var THIS = Accordion;
        THIS.onResize && window.removeEventListener("resize", THIS.onResize);
        if (false !== delay && (delay = +delay || 0) >= 0) {
          THIS.onResize = delay ? debounce(fn, delay) : fn;
          window.addEventListener("resize", THIS.onResize);
          if (delay)
            lastResizeRate = delay;
        }
      };
      Accordion.getAccordion = function(node) {
        while (node) {
          if ("accordion" in node)
            return accordions[node.accordion];
          node = node.parentNode;
          if (!node || node.nodeType !== 1)
            return null;
        }
      };
      Accordion.getFold = function(node) {
        while (node) {
          if ("accordionFold" in node)
            return folds[node.accordionFold];
          node = node.parentNode;
          if (!node || node.nodeType !== 1)
            return null;
        }
      };
      Accordion.setResizeRate(25);
      window.Accordion = Accordion;
      if ("object" === typeof module && "object" === typeof module.exports)
        module.exports.Accordion = Accordion;
      return Accordion;
    })();
  }
});
export default require_accordion();
//# sourceMappingURL=accordion.js.map
